use std::{
	collections::HashMap,
	fs,
	path::{Path, PathBuf},
};

use ethabi::{ethereum_types::H160, Contract};
use ethereum::ReceiptV3;

use crate::generic::utils::ESSENTIAL;

/// Liquidity-Pool solidity artifacts generated by build-script.
/// All needed contracts can be loaded from here
pub const LP_SOL_SOURCES: &str = env!("LP_SOL_SOURCES", "Build script failed to populate environment variable LP_SOL_SOURCES pointing to solidity source files.");

#[derive(Clone, Debug, PartialEq)]
pub struct DeployedContractInfo {
	pub contract: Contract,
	pub deployed_bytecode: Vec<u8>,
	pub address: H160,
}

impl DeployedContractInfo {
	pub fn new(contract: Contract, deployed_bytecode: Vec<u8>, address: H160) -> Self {
		Self {
			address,
			contract,
			deployed_bytecode,
		}
	}

	pub fn address(&self) -> H160 {
		H160::from(self.address)
	}
}

#[derive(Clone, Debug, PartialEq)]
pub struct ContractInfo {
	pub contract: Contract,
	pub bytecode: Vec<u8>,
	pub deployed_bytecode: Vec<u8>,
}

impl ContractInfo {
	pub fn new(contract: Contract, bytecode: Vec<u8>, deployed_bytecode: Vec<u8>) -> Self {
		Self {
			contract,
			bytecode,
			deployed_bytecode,
		}
	}
}

fn traversal(path: impl AsRef<Path>, files: &mut Vec<PathBuf>) {
	for path in fs::read_dir(path).expect("Submodules directory must exist for integration-tests") {
		if let Ok(dir_entry) = path.as_ref() {
			if dir_entry
				.metadata()
				.map(|meta| meta.is_dir())
				.unwrap_or(false)
			{
				traversal(
					fs::canonicalize(dir_entry.path()).expect("Failed to find absolute path."),
					files,
				)
			} else if dir_entry
				.metadata()
				.map(|meta| meta.is_file())
				.unwrap_or(false)
			{
				files.push(dir_entry.path())
			}
		}
	}
}

pub fn fetch_contracts() -> HashMap<String, ContractInfo> {
	let mut contracts = HashMap::new();
	let mut files = Vec::new();
	traversal(LP_SOL_SOURCES, &mut files);
	files.iter().for_each(|path| {
		let file_name = path
			.file_name()
			.expect("Only files here. qed.")
			.to_str()
			.expect(".sol files are valid unicode. qed")
			.split(".")
			.collect::<Vec<_>>();

		let contract_name = file_name
			.first()
			.expect("Files are all x.json.qed")
			.to_string();

		let contract_json: serde_json::Value =
			serde_json::from_reader(fs::File::open(path).expect(ESSENTIAL)).expect(ESSENTIAL);
		let abi = contract_json.get("abi").expect(ESSENTIAL);
		let _ = Contract::load(&mut serde_json::to_string(abi).expect(ESSENTIAL).as_bytes())
			.map_err(|e| {
				println!(
					"Error: Failed loading contract {}. Error: {}",
					contract_name, e
				)
			})
			.map(|contract| {
				// NOTE: We do not care of the code is invalid for now.
				let _ = hex::decode(
					contract_json
						.get("bytecode")
						.expect(ESSENTIAL)
						.get("object")
						.expect(ESSENTIAL)
						.as_str()
						.expect(ESSENTIAL)
						.trim_start_matches("0x"),
				)
				.map_err(|e| {
					println!(
						"Error: Failed decoding contract code {}. Error: {}",
						contract_name, e,
					)
				})
				.and_then(|code| {
					// NOTE: We do not care of the code is invalid for now.
					let deployed = hex::decode(
						contract_json
							.get("deployedBytecode")
							.expect(ESSENTIAL)
							.get("object")
							.expect(ESSENTIAL)
							.as_str()
							.expect(ESSENTIAL)
							.trim_start_matches("0x"),
					)
					.map_err(|e| {
						println!(
							"Error: Failed decoding deployed contract code {}. Error: {}",
							contract_name, e,
						)
					})?;

					Ok((code, deployed))
				})
				.map(|(code, deployed)| {
					// NOTE: There are some overlapping contract names in the LP codebase atm, but
					//       non that we care about for now. If we do care, we need to have some
					//       prefix or sort here.
					//
					//       For now: Use latest contract.
					contracts.insert(contract_name, ContractInfo::new(contract, code, deployed));
				});
			});
	});

	contracts
}

pub fn receipt_ok(receipt: ReceiptV3) -> bool {
	let inner = match receipt {
		ReceiptV3::Legacy(inner) | ReceiptV3::EIP1559(inner) | ReceiptV3::EIP2930(inner) => inner,
	};

	inner.status_code == 1
}

pub const fn deployment_config() -> evm::Config {
	evm::Config {
		gas_ext_code: 20,
		gas_ext_code_hash: 20,
		gas_balance: 20,
		gas_sload: 50,
		gas_sload_cold: 0,
		gas_sstore_set: 20000,
		gas_sstore_reset: 5000,
		refund_sstore_clears: 15000,
		max_refund_quotient: 2,
		gas_suicide: 0,
		gas_suicide_new_account: 0,
		gas_call: 40,
		gas_expbyte: 10,
		gas_transaction_create: 21000,
		gas_transaction_call: 21000,
		gas_transaction_zero_data: 4,
		gas_transaction_non_zero_data: 68,
		gas_access_list_address: 0,
		gas_access_list_storage_key: 0,
		gas_account_access_cold: 0,
		gas_storage_read_warm: 0,
		sstore_gas_metering: false,
		sstore_revert_under_stipend: false,
		increase_state_access_gas: false,
		decrease_clears_refund: false,
		disallow_executable_format: false,
		warm_coinbase_address: false,
		err_on_call_with_more_gas: true,
		empty_considered_exists: true,
		create_increase_nonce: false,
		call_l64_after_gas: false,
		stack_limit: 1024,
		memory_limit: usize::MAX,
		call_stack_limit: 1024,
		create_contract_limit: None,
		max_initcode_size: None,
		call_stipend: 2300,
		has_delegate_call: false,
		has_create2: false,
		has_revert: false,
		has_return_data: false,
		has_bitwise_shifting: false,
		has_chain_id: false,
		has_self_balance: false,
		has_ext_code_hash: false,
		has_base_fee: false,
		has_push0: false,
		estimate: false,
	}
}
