// Copyright 2021 Centrifuge Foundation (centrifuge.io).
//
// This file is part of the Centrifuge chain project.
// Centrifuge is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version (see http://www.gnu.org/licenses).
// Centrifuge is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

use cfg_types::tokens::CurrencyId;
use frame_support::{traits::OnRuntimeUpgrade, weights::Weight};

use crate::{AccountId, BlockRewards, ExistentialDeposit, NativeToken, OrmlAssetRegistry, Runtime};

pub type UpgradeCentrifuge1019 = (
	pallet_loans_ref::migrations::v1::Migration<Runtime>,
	session_key_migration::ExtendSessionKeys,
	pallet_block_rewards::migrations::InitBlockRewards<
		Runtime,
		init_block_rewards::CollatorRewards,
		init_block_rewards::TotalRewards,
	>,
	pallet_rewards::migrations::new_instance::FundExistentialDeposit<
		Runtime,
		pallet_rewards::Instance1,
		NativeToken,
		ExistentialDeposit,
	>,
	asset_registry::TrancheLocationMigration,
	evm_chain_id::SetEvmChainId,
);

mod init_block_rewards {
	use frame_support::parameter_types;

	use crate::{Balance, CFG, MILLI_CFG};

	parameter_types! {
		// = 16.65 CFG per epoch (12h)
		// https://gov.centrifuge.io/t/rfc-add-a-block-reward-and-improve-collators-cycle/4766
		pub const CollatorRewards: Balance = 8_325 * MILLI_CFG;
		// = 20,096 CFG per epoch (12h)
		pub const TotalRewards: Balance = 10_048 * CFG;
	}
}

mod session_key_migration {
	use frame_support::{
		dispatch::GetStorageVersion,
		inherent::Vec,
		pallet_prelude::{StorageVersion, ValueQuery},
		storage_alias,
	};
	use sp_runtime::impl_opaque_keys;
	#[cfg(feature = "try-runtime")]
	use {
		codec::{Decode, Encode},
		frame_benchmarking::Zero,
	};

	use super::*;
	use crate::{Aura, Session, SessionKeys};

	pub struct ExtendSessionKeys;

	impl_opaque_keys! {
		pub struct OldSessionKeys {
			pub aura: Aura,
		}
	}

	#[storage_alias]
	type QueuedKeys<T: pallet_session::Config> =
		StorageValue<pallet_session::Pallet<T>, Vec<(AccountId, OldSessionKeys)>, ValueQuery>;

	impl OnRuntimeUpgrade for ExtendSessionKeys {
		#[cfg(feature = "try-runtime")]
		fn pre_upgrade() -> Result<Vec<u8>, &'static str> {
			let queued: Vec<(AccountId, OldSessionKeys)> = QueuedKeys::<Runtime>::get();

			assert!(
				!queued.len().is_zero(),
				"Queued session keys must never be empty"
			);

			Ok(queued.encode())
		}

		fn on_runtime_upgrade() -> frame_support::weights::Weight {
			use sp_runtime::SaturatedConversion;

			// We must not bump the storage version of pallet_session to stay in sync with
			// Substrate. As this migration is tightly coupled to the initialization of
			// BlockRewards, it should be sane to trigger the session migration based on the
			// BlockRewards storage version.
			if BlockRewards::on_chain_storage_version() == StorageVersion::new(0) {
				Session::upgrade_keys::<OldSessionKeys, _>(|_, old_key| SessionKeys {
					aura: old_key.aura.clone(),
					block_rewards: old_key.aura,
				});

				let n: u64 = pallet_session::Validators::<Runtime>::get()
					.len()
					.saturated_into();

				<Runtime as frame_system::Config>::DbWeight::get()
					.reads_writes(n.saturating_add(1), n)
			} else {
				<Runtime as frame_system::Config>::DbWeight::get().reads(1)
			}
		}

		#[cfg(feature = "try-runtime")]
		fn post_upgrade(pre_state: Vec<u8>) -> Result<(), &'static str> {
			let pre_state: Vec<(AccountId, OldSessionKeys)> =
				Decode::decode(&mut pre_state.as_slice())
					.expect("Pre state parameter should be generated by pre-upgrade hooks");

			let queued: Vec<(AccountId, SessionKeys)> =
				pallet_session::QueuedKeys::<Runtime>::get();

			assert!(
				pre_state.len() == queued.len(),
				"Mismatch in number of session keys: pre {} vs post {}",
				pre_state.len(),
				queued.len()
			);

			pre_state.iter().zip(queued.into_iter()).for_each(
				|((pre_acc, pre_session_key), (post_acc, post_session_key))| {
					assert!(pre_acc == &post_acc, "Failed to match old validator key");
					assert!(
						&pre_session_key.aura == &post_session_key.aura,
						"Failed to match old aura key"
					);
					assert!(
						&pre_session_key.aura == &post_session_key.block_rewards,
						"Block rewards key does not match aura one"
					);
				},
			);

			Ok(())
		}
	}
}

mod asset_registry {
	use super::*;

	/// This migration sets the AssetMetadata.location of all the Tranche tokens
	/// registered in the AssetRegistry to `None`.
	pub struct TrancheLocationMigration;

	impl OnRuntimeUpgrade for TrancheLocationMigration {
		fn on_runtime_upgrade() -> Weight {
			for (asset_id, metadata) in orml_asset_registry::Metadata::<Runtime>::iter() {
				if matches!(asset_id, CurrencyId::Tranche(_, _)) && metadata.location.is_some() {
					match OrmlAssetRegistry::do_update_asset(
						asset_id,
						// decimals
						None,
						// name
						None,
						// symbol
						None,
						// existential_deposit
						None,
						// location: we do set it to `None`
						Some(None),
						// additional
						None,
					) {
						Err(e) => log::error!("TrancheLocationMigration: Failed to update asset with underlying error: {:?}", e),
						_ => continue,
					}
				}
			}

			// todo(nuno): not sure how to build this properly,
			// setting it to a conservative value for now.
			Weight::from_ref_time(200_000_000)
		}

		#[cfg(feature = "try-runtime")]
		fn pre_upgrade() -> Result<sp_std::vec::Vec<u8>, &'static str> {
			Ok(Default::default())
		}

		#[cfg(feature = "try-runtime")]
		fn post_upgrade(_: sp_std::vec::Vec<u8>) -> Result<(), &'static str> {
			for (asset_id, metadata) in orml_asset_registry::Metadata::<Runtime>::iter() {
				if matches!(asset_id, CurrencyId::Tranche(_, _)) {
					frame_support::ensure!(
						metadata.location.is_none(),
						"A tranche token's location is not None"
					);
				}
			}

			Ok(())
		}
	}
}

mod evm_chain_id {
	use pallet_evm_chain_id::ChainId;

	use super::*;
	use crate::{ParachainInfo, Runtime};

	/// This migration sets the EVM chain ID based on the parachain ID.
	pub struct SetEvmChainId;

	impl OnRuntimeUpgrade for SetEvmChainId {
		fn on_runtime_upgrade() -> Weight {
			let para_id: u32 = ParachainInfo::parachain_id().into();
			let evm_id: u64 = para_id.into();
			ChainId::<Runtime>::put(evm_id);
			<Runtime as frame_system::Config>::DbWeight::get().reads_writes(1, 1)
		}

		#[cfg(feature = "try-runtime")]
		fn pre_upgrade() -> Result<sp_std::vec::Vec<u8>, &'static str> {
			Ok(Default::default())
		}

		#[cfg(feature = "try-runtime")]
		fn post_upgrade(_: sp_std::vec::Vec<u8>) -> Result<(), &'static str> {
			// Migration is infallible
			Ok(())
		}
	}
}
